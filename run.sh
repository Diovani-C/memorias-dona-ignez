#!/bin/bash
# This script processes images using various containerized tools.
# It supports denoising, colorization, deblurring, preprocessing, and super resolution.
# It also supports chaining these actions.
#
# Each generated image is “marked” by creating a corresponding .generated file.
# Later, a check verifies that an image was generated by this script.
#
# Requirements: podman or docker

set -euo pipefail
IFS=$'\n\t'

# Enable nullglob so that globs with no matches expand to nothing.
shopt -s nullglob

# check_generated: Verifies that the output directory contains at least one image file.
check_generated() {
  local out_dir="$1"
  if ! find "$out_dir" -maxdepth 1 -type f \( -iname '*.png' -o -iname '*.jpg' -o -iname '*.jpeg' \) | grep -q .; then
    echo "Error: No image generated in directory '$out_dir'" >&2
    return 1
  fi
}

# mark_generated: For every image in the specified directory, create a corresponding marker file.
mark_generated() {
  local dir="$1"
  for img in "$dir"/*.{png,jpg,jpeg}; do
    if [ -f "$img" ] && [ ! -f "${img}.generated" ]; then
      touch "${img}.generated"
    fi
  done
}

# verify_generated_marker: Verifies that a given file has a corresponding .generated marker.
verify_generated_marker() {
  local file="$1"
  if [[ ! -f "${file}.generated" ]]; then
    echo "Warning: '$file' may not have been generated by this script." >&2
    return 1
  fi
}

# run_denoiser: Process images using the denoiser container.
run_denoiser() {
  local in_dir="$1"
  local out_dir="$2"
  podman run --gpus all -it \
    -v "$in_dir":/app/input:z \
    -v "$out_dir":/app/output:z \
    spandrel \
    python run.py -i /app/input/ -o /app/output/ --task denoise

  check_generated "$out_dir"
  mark_generated "$out_dir"
}

# run_colorization: Process images using the colorization container.
run_colorization() {
  local in_dir="$1"
  local out_dir="$2"
  podman run --gpus all -it \
    -v "$in_dir":/app/input:z \
    -v "$out_dir":/app/output:z \
    spandrel \
    python run.py -i /app/input/ -o /app/output/ --task color

  check_generated "$out_dir"
  mark_generated "$out_dir"
}

# run_deblur: Process images using the deblur container.
run_deblur() {
  local in_dir="$1"
  local out_dir="$2"
  podman run --gpus all -it \
    -v "$in_dir":/app/input:z \
    -v "$out_dir":/app/output:z \
    spandrel \
    python run.py -i /app/input/ -o /app/output/ --task deblur --cpu

  check_generated "$out_dir"
  mark_generated "$out_dir"
}

# run_superresolution: Process images using the super resolution container.
run_superresolution() {
  local in_dir="$1"
  local out_dir="$2"
  podman run --gpus all -it \
    -v "$in_dir":/app/input:z \
    -v "$out_dir":/app/output:z \
    spandrel \
    python run.py -i /app/input/ -o /app/output/ --task upscale_4x --cpu

  check_generated "$out_dir"
  mark_generated "$out_dir"
}

# run_face_restoration: Process images using the codeformer container.
run_face_restoration() {
  local in_dir="$1"
  local out_dir="$2"
  podman run --gpus all -it \
    -v "$in_dir":/app/input:z \
    -v "$out_dir":/app/output:z \
    spandrel \
    python run.py -i /app/input/ -o /app/output/ --task face --cpu

  check_generated "$out_dir"
  mark_generated "$out_dir"
}

# run_preprocessing: Resize and blur images based on user-selected operations.
run_preprocessing() {
  local in_dir="$1"
  local out_dir="$2"

  local processing_args=()

  echo "Select preprocessing operations:"
  echo "1) Gaussian Blur"
  echo "2) Guided Filter"
  echo "3) Enhance Contrast"
  echo "4) Sharpen"
  echo "5) Convert to Grayscale"
  echo "6) Resize"
  echo "7) All Done - Start Processing"

  while true; do
    read -rp "Choose an option (1-7): " proc_choice
    case "$proc_choice" in
    1)
      read -rp "Enter blur kernel size (odd number, e.g., 5): " ksize
      read -rp "Enter blur sigma (e.g., 0.8): " sigma
      processing_args+=(--apply_gaussian_blur --blur_ksize "$ksize" --blur_sigma "$sigma")
      ;;
    2)
      read -rp "Enter guided filter radius (e.g., 2): " gf_radius
      read -rp "Enter guided filter eps (e.g., 0.1): " gf_eps
      read -rp "Enter guided filter scale (e.g., 1): " gf_scale
      processing_args+=(--apply_guided_filter --gf_radius "$gf_radius" --gf_eps "$gf_eps" --gf_scale "$gf_scale")
      ;;
    3)
      processing_args+=(--enhance_contrast)
      ;;
    4)
      processing_args+=(--sharpen)
      ;;
    5)
      processing_args+=(--convert_grayscale)
      ;;
    6)
      read -rp "Enter resize ratio (e.g., 0.5 for half size): " ratio
      processing_args+=(--resize_ratio "$ratio")
      ;;
    7)
      break
      ;;
    *)
      echo "Invalid option, try again."
      ;;
    esac
    echo "Current operations: ${processing_args[*]}"
  done

  if [ ${#processing_args[@]} -gt 0 ]; then
    mkdir -p "$out_dir"
    podman run -it \
      -v "$in_dir":/app/input:z \
      -v "$out_dir":/app/output:z \
      image_processing \
      python run.py --input_dir ./input --output_dir ./output "${processing_args[@]}"

    check_generated "$out_dir"
    mark_generated "$out_dir"
  else
    echo "No processing operations selected."
  fi
}

# show_menu: Display the main menu.
show_menu() {
  echo "Choose an action:"
  echo "1) Denoiser"
  echo "2) Colorization"
  echo "3) Deblur"
  echo "4) Face Restoration"
  echo "5) Super Resolution"
  echo "6) Chain Actions"
  echo "7) Image Preprocessing"
  echo "8) Exit"
}

# execute_action: Execute a single action based on user choice.
execute_action() {
  case "$1" in
  1) run_denoiser "$(pwd)/input" "$(pwd)/output" ;;
  2) run_colorization "$(pwd)/input" "$(pwd)/output" ;;
  3) run_deblur "$(pwd)/input" "$(pwd)/output" ;;
  4) run_face_restoration "$(pwd)/input" "$(pwd)/output" ;;
  5) run_superresolution "$(pwd)/input" "$(pwd)/output" ;;
  7) run_preprocessing "$(pwd)/input" "$(pwd)/output" ;;
  8)
    echo "Exiting."
    exit 0
    ;;
  *)
    echo "Invalid option. Please try again."
    ;;
  esac
}

# execute_chain_actions: Execute a sequence of actions in chain mode.
execute_chain_actions() {
  echo "Enter a sequence of actions (numbers separated by spaces) to chain the actions."
  echo "Available actions: 1-Denoiser, 2-Colorization, 3-Deblur, 4-Face Restoration, 5-Super Resolution"
  # Temporarily set IFS to split on spaces for reading the sequence
  local old_ifs=$IFS
  IFS=$' \t\n'
  read -r -p "Enter your sequence: " -a chain_actions
  IFS=$old_ifs

  # Validate each action in the chain
  for action in "${chain_actions[@]}"; do
    if [[ ! "$action" =~ ^[1-5]$ ]]; then
      echo "Invalid action in chain: $action. Valid actions are 1-5." >&2
      return 1
    fi
  done

  # Create a temporary directory for chained processing.
  local chain_dir="$PWD/chain_temp"
  rm -rf "$chain_dir"
  mkdir -p "$chain_dir"

  # Start with the initial input folder.
  local prev_dir="$PWD/input"
  local counter=1

  for action in "${chain_actions[@]}"; do
    local current_dir="$chain_dir/step_$counter"
    mkdir -p "$current_dir"
    echo "Executing action $action on data from '$prev_dir' -> output to '$current_dir'..."
    case "$action" in
    1) run_denoiser "$prev_dir" "$current_dir" ;;
    2) run_colorization "$prev_dir" "$current_dir" ;;
    3) run_deblur "$prev_dir" "$current_dir" ;;
    4) run_face_restoration "$prev_dir" "$current_dir" ;;
    5) run_superresolution "$prev_dir" "$current_dir" ;;
    esac || {
      echo "Error executing action $action. Aborting chain." >&2
      return 1
    }
    prev_dir="$current_dir"
    counter=$((counter + 1))
  done

  # Copy the final chained output to the 'output' folder.
  rm -rf output
  mkdir -p output
  if [ -n "$(ls -A "$prev_dir")" ]; then
    cp -r "$prev_dir"/* output/
    echo "Chained actions complete. Final output is in the 'output' folder."
  else
    echo "Error: No files generated in the final chain directory '$prev_dir'" >&2
    return 1
  fi

  # Verify that each image in the output directory has a marker.
  for img in output/*.{png,jpg,jpeg}; do
    if [ -f "$img" ]; then
      verify_generated_marker "$img" || echo "Image $img might not have been generated by this script."
    fi
  done
}

# Main loop.
while true; do
  show_menu
  read -rp "Enter your choice [1-8]: " choice
  if [ "$choice" -eq 6 ]; then
    execute_chain_actions
  else
    execute_action "$choice"
  fi
done
